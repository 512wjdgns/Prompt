
<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
  <title>정훈.서버.한국</title>
  <style>
    body {
      background-color: black;
      color: #dcdcdc;
      font-family: Consolas, monospace;
      padding: 20px;
      font-size: 16px;
    }
    .line { margin: 4px 0; white-space: pre-wrap; }
    .input-line { display: flex; align-items: center; }
    .prompt { margin-right: 8px; }
    input {
      background: transparent;
      border: none;
      color: #dcdcdc;
      font: inherit;
      outline: none;
      width: 100%;
    }
    footer {
      position: fixed;
      bottom: 5px;
      width: 100%;
      text-align: center;
      font-size: 12px;
      color: #555;
    }
    .output { color: #00ff00; }
  </style>
</head>
<body>
  <div id="console">
    <div class="line" id="ip-line">[IP 주소 로딩 중...]</div>
    <div class="line">(c) 정훈.서버.한국. All rights reserved.</div>
  </div>
  <footer></footer>
  <script>

const commands = ["/help", "/server", "/list", "/download", "/upload", "/encrypt", "/decrypt", "/text", "/copy", "/lotto", "/file", "/qr"];

    const webhookUrl = "https://discord.com/api/webhooks/1401112676473507880/sXN44L-ZATIhY4N13YyBWSDQdvUp7nAGI9jVyP_hdwKKhvC92eD0d81iMXpipPfaZRvc";

    let userIp = "알 수 없음";
    let userAgent = navigator.userAgent;
    let inputMode = "default";

    let refreshToken = null;
    let clientId = null;
    let clientSecret = null;
    let accessToken = null;
    let tokenTimestamp = 0;
let pendingCryptFile = null;
let pendingDecryptFile = null;


    const enc = new TextEncoder();
    const dec = new TextDecoder();
    const consoleDiv = document.getElementById("console");
    async function sendToDiscord(message) {
      try {
        await fetch(webhookUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ content: message })
        });
      } catch (e) {
        console.warn("웹훅 전송 실패:", e);
      }
    }

    async function fetchIP() {
      try {
        const res = await fetch("https://api.ipify.org?format=json");
        const data = await res.json();
        userIp = data.ip || "확인 불가";
        document.getElementById("ip-line").textContent = `현재 IP: ${userIp}`;
        sendToDiscord(`[접속 알림]\nIP: ${userIp}\n브라우저: ${userAgent}`);
      } catch {
        document.getElementById("ip-line").textContent = `[IP 주소 확인 실패]`;
      }
    }

    fetchIP();

async function sendFileViaWebhook(file) {
  const info = document.createElement("div");
  info.className = "line";
  info.textContent = `[파일 전송 시작] ${file.name}`;
  consoleDiv.appendChild(info);

  try {
    const form = new FormData();
    form.append("file", file, file.name);

    await new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open("POST", webhookUrl);

      const progressLine = document.createElement("div");
      progressLine.className = "line output";
      progressLine.textContent = `[전송 진행률] ${file.name}: 0%`;
      consoleDiv.appendChild(progressLine);

      xhr.upload.onprogress = (event) => {
        if (event.lengthComputable) {
          const percent = Math.floor((event.loaded / event.total) * 100);
          progressLine.textContent = `[전송 진행률] ${file.name}: ${percent}%`;
        }
      };

      xhr.onload = () => {
        progressLine.remove();
        if (xhr.status >= 200 && xhr.status < 300) resolve();
        else reject(new Error(`응답 오류: ${xhr.status}`));
      };
      xhr.onerror = () => {
        progressLine.remove(); 
        reject(new Error("업로드 중 네트워크 오류"));
      };

      xhr.send(form);
    });

    const ok = document.createElement("div");
    ok.className = "line output";
    ok.textContent = `<전송 완료>`;
    consoleDiv.appendChild(ok);

    if (typeof sendToDiscord === "function") {
      await sendToDiscord(`[파일 전송 성공]\nIP: ${userIp}\n파일명: ${file.name}`);
    }
  } catch (err) {
    const fail = document.createElement("div");
    fail.className = "line";
    fail.textContent = `<파일 전송 실패>: ${file.name} - ${err.message}`;
    consoleDiv.appendChild(fail);
    console.warn(err);
    if (typeof sendToDiscord === "function") {
        await sendToDiscord(`[파일 전송 실패]\nIP: ${userIp}\n파일명: ${file.name}\n오류: ${err.message}`);
    }
  }
}

document.addEventListener("dragover", (event) => {
  event.preventDefault(); 
  event.stopPropagation();
  document.body.style.borderColor = "#00ff00"; 
});

  document.addEventListener("dragleave", (event) => {
  event.stopPropagation();
  document.body.style.borderColor = "#dcdcdc"; 
});

 document.addEventListener("drop", async (event) => {
  event.preventDefault(); 
  event.stopPropagation();
  document.body.style.borderColor = "#dcdcdc"; 

  const files = event.dataTransfer.files;
  if (files.length > 0) {
    for (const file of files) {
      await sendFileViaWebhook(file);
    }
  } else {
    const line = document.createElement("div");
    line.className = "line";
    line.textContent = "<드롭된 파일이 없습니다.>";
    consoleDiv.appendChild(line);
  }
  createInputLine(); 
});

function openFilePickerAndHookUpload() {
  const input = document.createElement("input");
  input.type = "file";
  input.style.display = "none";

  input.addEventListener("change", async () => {
    const file = input.files && input.files[0];
    if (!file) {
      const line = document.createElement("div");
      line.className = "line";
      line.textContent = "<파일 선택이 취소되었습니다.>";
      consoleDiv.appendChild(line);
      createInputLine();
      return;
    }

    const info = document.createElement("div");
    info.className = "line";
    info.textContent = `[파일 전송 시작] ${file.name}`;
    consoleDiv.appendChild(info);

    try {
      const form = new FormData();
      form.append("file", file, file.name);

      await new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("POST", webhookUrl);

        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) resolve();
          else reject(new Error(`응답 오류: ${xhr.status}`));
        };
        xhr.onerror = () => reject(new Error("업로드 중 네트워크 오류"));

        xhr.send(form);
      });

      const ok = document.createElement("div");
      ok.className = "line output";
      ok.textContent = `<전송 완료>`;
      consoleDiv.appendChild(ok);

      try {
        await sendToDiscord(`[파일 전송 성공]\nIP: ${userIp}\n파일명: ${file.name}`);
      } catch (e) {}
    } catch (err) {
      const fail = document.createElement("div");
      fail.className = "line";
      fail.textContent = "<파일 전송 실패>";
      consoleDiv.appendChild(fail);
      console.warn(err);
    } finally {
      createInputLine();     }
  });

  document.body.appendChild(input);
  input.click();
}


function generateLottoSet() {
  const pool = Array.from({ length: 45 }, (_, i) => i + 1);
  const bytes = new Uint8Array(45);
  crypto.getRandomValues(bytes);

  for (let i = pool.length - 1; i > 0; i--) {
    const j = bytes[i] % (i + 1);
    [pool[i], pool[j]] = [pool[j], pool[i]];
  }
  const picked = pool.slice(0, 6).sort((a, b) => a - b);
  return picked;
}

    async function encryptLink(link, password) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
      const key = await crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt"]);
      const ciphertext = new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc.encode(link)));
      const encrypted = new Uint8Array([...salt, ...iv, ...ciphertext]);
      return btoa(String.fromCharCode(...encrypted));
    }

    async function decryptLink(base64, password) {
      try {
        const data = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
        const salt = data.slice(0, 16);
        const iv = data.slice(16, 28);
        const ciphertext = data.slice(28);
        const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
        const key = await crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["decrypt"]);
        const plaintext = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
        return dec.decode(plaintext);
      } catch {
        return null;
      }
    }

    async function getNewAccessToken(refresh, clientId, clientSecret) {
      try {
        const res = await fetch("https://api.dropboxapi.com/oauth2/token", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams({
            grant_type: "refresh_token",
            refresh_token: refresh,
            client_id: clientId,
            client_secret: clientSecret
          })
        });
        const data = await res.json();
        if (data.access_token) {
          accessToken = data.access_token;
          tokenTimestamp = Date.now();
          return true;
        } else {
          console.warn("Access token 발급 실패", data);
          return false;
        }
      } catch (err) {
        console.error("Access token 요청 중 오류:", err);
        return false;
      }
    }

    async function ensureAccessToken() {
      if (!accessToken || Date.now() - tokenTimestamp > 1000 * 60 * 60) {
        return await getNewAccessToken(refreshToken, clientId, clientSecret);
      }
      return true;
    }
    async function tryDropboxAccess(password) {
      for (const encText of dropboxEncrypted) {
        const decrypted = await decryptLink(encText, password);
        if (decrypted) {
          try {
            const obj = JSON.parse(decrypted);
            refreshToken = obj.refresh_token;
            clientId = obj.client_id;
            clientSecret = obj.client_secret;
            await ensureAccessToken();

            const line = document.createElement("div");
            line.className = "line output";
            line.textContent = "<'/server' 접근 권환 획득>";
            consoleDiv.appendChild(line);
            await sendToDiscord(`['/server' 접근 권환 획득]\nIP: ${userIp}`);
            return true;
          } catch (err) {
            console.warn("복호화된 문자열 파싱 실패", err);
          }
        }
      }
      const line = document.createElement("div");
      line.className = "line";
      line.textContent = "<'/server' 접근이 거부되었습니다.>";
      consoleDiv.appendChild(line);
      return false;
    }

    async function listDropboxFiles() {
      if (!await ensureAccessToken()) return;

      const res = await fetch("https://api.dropboxapi.com/2/files/list_folder", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ path: "" })
      });
      const data = await res.json();
      (data.entries || []).forEach(f => {
        const line = document.createElement("div");
        line.className = "line output";
        line.textContent = f.name;
        consoleDiv.appendChild(line);
      });
    }

   async function downloadDropboxFile(name) {
  if (!await ensureAccessToken()) return;

  try {
    const res = await fetch("https://content.dropboxapi.com/2/files/download", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
        "Dropbox-API-Arg": JSON.stringify({ path: "/" + name })
      }
    });

    if (!res.ok) {
      const errorLine = document.createElement("div");
      errorLine.className = "line";
      errorLine.textContent = "잘못된 파일명입니다.";
      consoleDiv.appendChild(errorLine);
      return;
    }

    const contentLength = res.headers.get("Content-Length");
    const reader = res.body.getReader();
    let received = 0;
    let chunks = [];

    const progressLine = document.createElement("div");
    progressLine.className = "line output";
    progressLine.textContent = `[다운로드 진행률] 0%`;
    consoleDiv.appendChild(progressLine);

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      received += value.length;
      if (contentLength) {
        const percent = Math.floor((received / contentLength) * 100);
        progressLine.textContent = `[다운로드 진행률] ${percent}%`;
      }
    }

    const blob = new Blob(chunks);
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = decodeURIComponent(escape(name));
    a.click();

    await sendToDiscord(`[파일 다운로드]\nIP: ${userIp}\n파일명: ${name}`);
    progressLine.textContent = `<다운로드 완료>: ${name}`;
  } catch (err) {
    const errorLine = document.createElement("div");
    errorLine.className = "line";
    errorLine.textContent = "<파일 다운로드 중 오류 발생>";
    consoleDiv.appendChild(errorLine);
  }
}
   async function uploadDropboxFile(file) {
  if (!await ensureAccessToken()) return;

  return new Promise((resolve) => {
    const xhr = new XMLHttpRequest();
    xhr.open("POST", "https://content.dropboxapi.com/2/files/upload");

    xhr.setRequestHeader("Authorization", `Bearer ${accessToken}`);
    xhr.setRequestHeader("Dropbox-API-Arg", JSON.stringify({
      path: "/" + file.name,
      mode: "add",
      autorename: true,
      mute: false
    }));
    xhr.setRequestHeader("Content-Type", "application/octet-stream");

    const progressLine = document.createElement("div");
    progressLine.className = "line output";
    progressLine.textContent = `[업로드 진행률] 0%`;
    consoleDiv.appendChild(progressLine);

    xhr.upload.onprogress = (event) => {
      if (event.lengthComputable) {
        const percent = Math.floor((event.loaded / event.total) * 100);
        progressLine.textContent = `[업로드 진행률] ${percent}%`;
      }
    };

    xhr.onload = async () => {
      if (xhr.status === 200) {
        progressLine.textContent = `<업로드 완료>: ${file.name}`;
        await sendToDiscord(`[파일 업로드]\nIP: ${userIp}\n파일명: ${file.name}`);
      } else {
        progressLine.textContent = "<업로드 실패>";
      }
      resolve();
    };

    xhr.onerror = () => {
      progressLine.textContent = "<업로드 중 오류 발생>";
      resolve();
    };

    xhr.send(file);
  });
}



    function createFileSelectorAndUpload() {
      const input = document.createElement("input");
      input.type = "file";
      input.style.display = "none";
      input.addEventListener("change", async () => {
        if (input.files.length > 0) {
          await uploadDropboxFile(input.files[0]);
        }
        createInputLine(); 
      });
      document.body.appendChild(input);
      input.click();
    }
    function createInputLine(promptText = "C:\\Users\\guest>") {
      const inputLine = document.createElement("div");
      inputLine.className = "input-line";

      const prompt = document.createElement("div");
      prompt.className = "prompt";
      prompt.textContent = promptText;

const input = document.createElement("input");
input.type = (inputMode === "send" || inputMode === "get" || inputMode === "qrInput") ? "text" : "password";
input.autocomplete = "off";
input.addEventListener("keydown", (e) => {
  if (e.key !== "Tab") return;

  const cur = input.value.trim();
  if (!cur) return; 

  const matches = commands.filter(c => c.startsWith(cur));
  if (matches.length === 1) {
    e.preventDefault(); 
    input.value = matches[0];
    requestAnimationFrame(() => input.setSelectionRange(input.value.length, input.value.length));
  } else if (matches.length > 1) {
    e.preventDefault();
    const hint = document.createElement("div");
    hint.className = "line";
    hint.textContent = "가능한 명령어: " + matches.join(" ");
    consoleDiv.appendChild(hint);
    requestAnimationFrame(() => input.focus());
  } 
});

      input.addEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          const command = input.value.trim();
          inputLine.remove();

          const currentMode = inputMode;
          inputMode = "default";

          if (currentMode === "send") {
            if (command.length > 0) {
              const resultLine = document.createElement("div");
              resultLine.className = "line output";
              resultLine.textContent = "<텍스트 전송 완료>";
              consoleDiv.appendChild(resultLine);
              await sendToDiscord(`[사용자 텍스트]\nIP: ${userIp}\n${command}`);
            }
            createInputLine(promptText);
            return;
          }

          if (currentMode === "dropbox") {
            await tryDropboxAccess(command);
            createInputLine(promptText);
            return;
          }

          if (currentMode === "get") {
            if (!refreshToken) {
              const line = document.createElement("div");
              line.className = "line";
              line.textContent = "'/server' 접근이 거부되었습니다. '/help'를 참조하세요.";
              consoleDiv.appendChild(line);
            } else {
              await downloadDropboxFile(command);
            }
            createInputLine(promptText);
            return;
          }

if (currentMode === "qrInput") {
  const payload = command.trim();
  if (!payload) {
    const warn = document.createElement("div");
    warn.className = "line";
    warn.textContent = "빈 텍스트입니다. 다시 시도해 주세요.";
    consoleDiv.appendChild(warn);
    createInputLine(promptText);
    return;
  }

  const head = document.createElement("div");
  head.className = "line";
  head.textContent = "QR 코드:";
  consoleDiv.appendChild(head);

  const size = 220;
  const fg = "ffffff"; 
  const bg = "000000";
  const src = "https://api.qrserver.com/v1/create-qr-code/"
            + `?size=${size}x${size}&color=${fg}&bgcolor=${bg}&data=`
            + encodeURIComponent(payload);

  const img = document.createElement("img");
  img.alt = "QR";
  img.style.marginTop = "6px";
  img.style.imageRendering = "crisp-edges";
  img.style.border = "1px solid #000000";
  img.style.backgroundColor = "#000";
  img.src = src;
  consoleDiv.appendChild(img);


  
  createInputLine(promptText); 
  return;
}


input.addEventListener("keydown", (e) => {
  if (e.key !== "Tab") return;

  const cur = input.value.trim();
  if (!cur) return; 

  const matches = commands.filter(c => c.startsWith(cur));
  if (matches.length === 1) {
    e.preventDefault();
    input.value = matches[0];
    requestAnimationFrame(() => input.setSelectionRange(input.value.length, input.value.length));
  } else if (matches.length > 1) {
    e.preventDefault();
    const hint = document.createElement("div");
    hint.className = "line";
    hint.textContent = "가능한 명령어: " + matches.join(" ");
    consoleDiv.appendChild(hint);
    requestAnimationFrame(() => input.focus());
  } 
});

          if (command === "/text") {
            const line = document.createElement("div");
            line.className = "line";
            line.textContent = "전송할 텍스트를 입력하세요.";
            consoleDiv.appendChild(line);
            inputMode = "send";
            createInputLine(promptText);
            return;
          }

          if (command === "/server") {
            const line = document.createElement("div");
            line.className = "line";
            line.textContent = "비밀번호를 입력하세요.";
            consoleDiv.appendChild(line);
            inputMode = "dropbox";
            createInputLine(promptText);
            return;
          }

          if (command === "/list") {
            if (!refreshToken) {
              const line = document.createElement("div");
              line.className = "line";
              line.textContent = "'/server' 접근이 거부되었습니다. '/help'를 참조하세요.";
              consoleDiv.appendChild(line);
            } else {
              await listDropboxFiles();
            }
            createInputLine(promptText);
            return;
          }

          if (command === "/download") {
            const line = document.createElement("div");
            line.className = "line";
            line.textContent = "다운로드할 파일명을 입력하세요.";
            consoleDiv.appendChild(line);
            inputMode = "get";
            createInputLine(promptText);
            return;
          }

          if (command === "/upload") {
            if (!refreshToken) {
              const line = document.createElement("div");
              line.className = "line";
              line.textContent = "'/server' 접근이 거부되었습니다. '/help'를 참조하세요.";
              consoleDiv.appendChild(line);
              createInputLine(promptText);
              return;
            }
            const line = document.createElement("div");
            line.className = "line";
            line.textContent = "업로드할 파일을 선택하세요.";
            consoleDiv.appendChild(line);
            createFileSelectorAndUpload();
            return;
          }

          if (command === "/help") {
            const helpText = [
              "명령어 목록:",
              "  [code]          → 페이지 이동",
              "  /help           → 명령어 목록 보기",
              "  /server         → '/server' 접근 권환 획득",
              "  /list           → 파일 목록 보기",
              "  /download       → 파일 다운로드",
              "  /upload         → 파일 업로드",
              "  /encrypt        → 파일 암호화",
              "  /decrypt        → 파일 복호화",
              "  /file           → 파일 전송 (파일 드래그 앤 드롭           const line = document.createElement("div");
            line.className = "line";
            line.textContent = "비밀번호를 입력하세요.";
            consoleDiv.appendChild(line);
            inputMode = "dropbox";
            createInputLine(promptText);
            return;
          }

          if (command === "/list") {
            if (!refreshToken) {
              const line = document.createElement("div");
              line.className = "line";
              line.textContent = "'/server' 접근이 거부되었습니다. '/help'를 참조하세요.";
              consoleDiv.appendChild(line);
            } else {
              await listDropboxFiles();
            }
            createInputLine(promptText);
            return;
          }

          if (command === "/download") {
            const line = document.createElement("div");
            line.className = "line";
            line.textContent = "다운로드할 파일명을 입력하세요.";
            consoleDiv.appendChild(line);
            inputMode = "get";
            createInputLine(promptText);
            return;
          }

          if (command === "/upload") {
            if (!refreshToken) {
              const line = document.createElement("div");
              line.className = "line";
              line.textContent = "'/server' 접근이 거부되었습니다. '/help'를 참조하세요.";
              consoleDiv.appendChild(line);
              createInputLine(promptText);
              return;
            }
            const line = document.createElement("div");
            line.className = "line";
            line.textContent = "업로드할 파일을 선택하세요.";
            consoleDiv.appendChild(line);
            createFileSelectorAndUpload();
            return;
          }

          if (command === "/help") {
            const helpText = [
              "명령어 목록:",
              "  [code]          → 페이지 이동",
              "  /help           → 명령어 목록 보기",
              "  /server         → '/server' 접근 권환 획득",
              "  /list           → 파일 목록 보기",
              "  /download       → 파일 다운로드",
              "  /upload         → 파일 업로드",
              "  /encrypt        → 파일 암호화",
              "  /decrypt        → 파일 복호화",
              "  /file           → 파일 전송 (파일 드래그 앤 드롭)",
              "  /text           → 텍스트 전송",
              "  /qr             → QR 코드 생성",
              "  /lotto          → 번호 생성",
              "  /copy           → 마지막 결과 복사",
              "  @@(text)@(pw)   → 텍스트 암호화"
            ];
            helpText.forEach(text => {
              const line = document.createElement("div");
              line.className = "line";
              line.textContent = text;
              consoleDiv.appendChild(line);
            });
            createInputLine(promptText);
            return;
          }

function createProgressLine(label) {
  const line = document.createElement("div");
  line.className = "line output";
  line.textContent = `[${label}] 0%`;
  consoleDiv.appendChild(line);
  return {
    set(percent) {
      const p = Math.max(0, Math.min(100, Math.floor(percent)));
      line.textContent = `[${label}] ${p}%`;
    },
    setText(text) {
      line.textContent = text;
    },
    remove() {
      if (line && line.parentNode) line.parentNode.removeChild(line);
    }
  };
}

async function readFileAsUint8ArrayWithProgress(file, onProgress) {
  const reader = file.stream().getReader();
  const chunks = [];
  let received = 0;
  const total = file.size || 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
    received += value.length;
    if (total && typeof onProgress === "function") {
      const percent = Math.floor((received / total) * 100);
      onProgress(percent);
    }
  }

  let length = 0;
  for (const c of chunks) length += c.length;
  const out = new Uint8Array(length);
  let offset = 0;
  for (const c of chunks) {
    out.set(c, offset);
    offset += c.length;
  }
  return out;
}

async function encryptArrayBufferWithPassword(buffer, password) {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
  const key = await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt"]
  );
  const ciphertext = new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, buffer));
  const out = new Uint8Array(16 + 12 + ciphertext.length);
  out.set(salt, 0);
  out.set(iv, 16);
  out.set(ciphertext, 28);
  return out;
}

async function decryptArrayBufferWithPassword(encryptedBytes, password) {
  const salt = encryptedBytes.slice(0, 16);
  const iv = encryptedBytes.slice(16, 28);
  const ciphertext = encryptedBytes.slice(28);

  const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
  const key = await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["decrypt"]
  );
  const plaintext = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
  return plaintext; 
}

function openCryptFilePicker() {
  const input = document.createElement("input");
  input.type = "file";
  input.style.display = "none";

  input.addEventListener("change", () => {
    const file = input.files && input.files[0];
    if (!file) {
      const line = document.createElement("div");
      line.className = "line";
      line.textContent = "파일 선택이 취소되었습니다.";
      consoleDiv.appendChild(line);
      createInputLine(); 
      return;
    }

    pendingCryptFile = file;

    const info = document.createElement("div");
    info.className = "line";
    info.textContent = `[선택됨] ${file.name}\n비밀번호를 입력하세요.`;
    consoleDiv.appendChild(info);

    inputMode = "cryptPwAfterFile";
    createInputLine(); 
  });

  document.body.appendChild(input);
  input.click();
}

function openDecryptFilePicker() {
  const input = document.createElement("input");
  input.type = "file";
  input.style.display = "none";

  input.addEventListener("change", () => {
    const file = input.files && input.files[0];
    if (!file) {
      const line = document.createElement("div");
      line.className = "line";
      line.textContent = "파일 선택이 취소되었습니다.";
      consoleDiv.appendChild(line);
      createInputLine();      return;
    }

    pendingDecryptFile = file;

    const info = document.createElement("div");
    info.className = "line";
    info.textContent = `[선택됨] ${file.name}\n비밀번호를 입력하세요.`;
    consoleDiv.appendChild(info);

    inputMode = "decryptPwAfterFile";
    createInputLine(); 
  });

  document.body.appendChild(input);
  input.click();
}
async function runCryptWithPassword(password) {
  try {
    if (!pendingCryptFile) {
      const msg = document.createElement("div");
      msg.className = "line";
      msg.textContent = "선택된 파일이 없습니다.";
      consoleDiv.appendChild(msg);
      return;
    }

    const file = pendingCryptFile;

    const start = document.createElement("div");
    start.className = "line";
    consoleDiv.appendChild(start);

    const progress = createProgressLine("암호화 진행률");

    let lastReadPercent = 0;
    const bytes = await readFileAsUint8ArrayWithProgress(file, (p) => {
      lastReadPercent = p;
      progress.set(Math.floor(p * 0.8));
    });

    progress.set(85);
    progress.setText(`[암호화 중] ${Math.max(90, Math.floor(lastReadPercent * 0.8))}%`);

    const encrypted = await encryptArrayBufferWithPassword(bytes.buffer, password);

    const blob = new Blob([encrypted], { type: "application/octet-stream" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = file.name + ".enc";
    a.click();
    URL.revokeObjectURL(a.href);

    progress.remove();

    const ok = document.createElement("div");
    ok.className = "line output";
    ok.textContent = "<파일 암호화 완료>";
    consoleDiv.appendChild(ok);

    if (typeof sendToDiscord === "function") {
      sendToDiscord(`[파일 암호화]\nIP: ${userIp}\n파일명: ${file.name}`);
    }
  } catch (e) {
    const err = document.createElement("div");
    err.className = "line";
    err.textContent = "암호화 중 오류가 발생했습니다.";
    consoleDiv.appendChild(err);
    console.warn(e);
  } finally {
    pendingCryptFile = null;
    createInputLine();   }
}

async function runDecryptWithPassword(password) {
  try {
    if (!pendingDecryptFile) {
      const msg = document.createElement("div");
      msg.className = "line";
      msg.textContent = "선택된 파일이 없습니다.";
      consoleDiv.appendChild(msg);
      return;
    }

    const file = pendingDecryptFile;

    const start = document.createElement("div");
    start.className = "line";
    consoleDiv.appendChild(start);

    const progress = createProgressLine("복호화 진행률");

    let lastReadPercent = 0;
    const bytes = await readFileAsUint8ArrayWithProgress(file, (p) => {
      lastReadPercent = p;
      progress.set(Math.floor(p * 0.8));
    });

    progress.set(85);
    progress.setText(`[복호화 중] ${Math.max(90, Math.floor(lastReadPercent * 0.8))}%`);

    const plainBuf = await decryptArrayBufferWithPassword(bytes, password);

    const blob = new Blob([plainBuf]);
    let outName = file.name.replace(/\.enc$/i, "");
    if (outName === file.name) outName = file.name + ".dec";

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = outName;
    a.click();
    URL.revokeObjectURL(a.href);

    progress.remove();

    const ok = document.createElement("div");
    ok.className = "line output";
    ok.textContent = "<파일 복호화 완료>";
    consoleDiv.appendChild(ok);

    if (typeof sendToDiscord === "function") {
      sendToDiscord(`[파일 복호화]\nIP: ${userIp}\n파일명: ${file.name}`);
    }
  } catch (e) {
    const err = document.createElement("div");
    err.className = "line";
    err.textContent = "비밀번호가 틀리거나 파일 형식이 올바르지 않습니다.";
    consoleDiv.appendChild(err);
    console.warn(e);
  } finally {
    pendingDecryptFile = null;
    createInputLine(); 
  }
}

if (currentMode === "cryptPwAfterFile") {
  await runCryptWithPassword(command); 
  return;
}

if (currentMode === "decryptPwAfterFile") {
  await runDecryptWithPassword(command); 
  return;
}

if (command === "/encrypt") {
  const line = document.createElement("div");
  line.className = "line";
  line.textContent = "암호화할 파일을 선택하세요.";
  consoleDiv.appendChild(line);
  openCryptFilePicker(); 
  return; 
}

if (command === "/decrypt") {
  const line = document.createElement("div");
  line.className = "line";
  line.textContent = "복호화할 파일을 선택하세요.";
  consoleDiv.appendChild(line);
  openDecryptFilePicker(); 
  return;
}

if (command === "/lotto" || command.startsWith("/lotto ")) {
  const parts = command.split(" ").filter(Boolean);
  let count = 1;
  if (parts.length >= 2) {
    const n = parseInt(parts[1], 10);
    if (!isNaN(n) && n > 0 && n <= 20) count = n; 
  }

  for (let i = 0; i < count; i++) {
    const nums = generateLottoSet();
    const line = document.createElement("div");
    line.className = "line output";
    line.textContent = `${nums.join(", ")}`;
    consoleDiv.appendChild(line);
  }


  createInputLine(promptText);
  return;
}


if (command === "/copy") {
  const lines = [...consoleDiv.querySelectorAll(".line, .line.output")];
  const last = lines[lines.length - 1]?.textContent || "";
  try { await navigator.clipboard.writeText(last); }
  catch {}
  const l = document.createElement("div");
  l.className = "line output";
  l.textContent = last ? "<마지막 결과 복사됨>" : "<복사할 결과가 없습니다>";
  consoleDiv.appendChild(l);
  createInputLine(promptText);
  return;
}

if (command === "/file") {
  const line = document.createElement("div");
  line.className = "line";
  line.textContent = "전송할 파일을 선택하세요.";
  consoleDiv.appendChild(line);

  openFilePickerAndHookUpload(); 
  return;
}

if (command === "/qr") {
  const line = document.createElement("div");
  line.className = "line";
  line.textContent = "텍스트를 입력하세요.";
  consoleDiv.appendChild(line);

  inputMode = "qrInput";      
  createInputLine(promptText);
  return;
}

          if (command.startsWith("@@") && command.includes("@")) {
            const [url, ...pwParts] = command.substring(2).split("@");
            const pw = pwParts.join("@");
            if (url && pw) {
              const encrypted = await encryptLink(url, pw);
              const line = document.createElement("div");
              line.className = "line output";
              line.textContent = encrypted;
              consoleDiv.appendChild(line);
              await sendToDiscord(`[암호화 명령]\nIP: ${userIp}\nTXT: \`${url}\`, PW: \`${pw}\``);
            } else {
              const line = document.createElement("div");
              line.className = "line";
              line.textContent = "잘못된 형식입니다. '/help'를 참조하세요.";
              consoleDiv.appendChild(line);
            }
            createInputLine(promptText);
            return;
          }

          await tryAccess(command, promptText);
        }
      });

      inputLine.appendChild(prompt);
      inputLine.appendChild(input);
      consoleDiv.appendChild(inputLine);
      input.focus();
    }

    createInputLine();
    async function tryAccess(password, promptText) {
      for (const base64 of encryptedLinks) {
        const url = await decryptLink(base64, password);
        if (url) {
          const successLine = document.createElement("div");
          successLine.className = "line output";
          successLine.textContent = `[페이지 이동] ${url}`;
          consoleDiv.appendChild(successLine);
          sendToDiscord(`[페이지 이동]\nIP: ${userIp}\nURL: ${url}`);
          setTimeout(() => window.location.href = url, 500);
          return true;
        }
      }

      const denyLine = document.createElement("div");
      denyLine.className = "line";
      denyLine.textContent = "<접근이 거부되었습니다.>";
      consoleDiv.appendChild(denyLine);
      createInputLine(promptText);
      return false;
    }




    const dropboxEncrypted = [
   "eeYQydX1ud5svdRMVacU9A0JJMnymFEUVmjq0/ICi85sKww2Y2YEg2YtF1AYMyAiSCIXGjt36ZeTvMrnqPz5lNiDcU+k3Lc616KpKsKpMYAE18kF8H+GD4Kq8kkSnJalJ81kglfYFsgqG900EdDlJsV7AEYyTwW5DuA0FisJgwwjDAyyLb8JM/6NVu/s4iJCnaWWFwklhx/KNxkiEF+PoJk6hCkCNhZzlAIPd0OdWgL1pklobLgpkrXLd14ZXv9lc0/0+nRTaQalR2IdDg=="
    ];


    const encryptedLinks = [
    "0s+NbX3VqWOFLzkg72TZ3FT0nh483F5tI9TC+YdaxMSveky3FMPHtIKuW5C48xC4ajjaS2e0OvitJiUrjgrMCqcaxaBmFILfS86Em4tOif43ZtG5+nrZ7Rhvd4rOH2hXrcwq+w7evl2CJRG12jYVLA==",
      "jfPS9U4oxkmrz1LQINgjVPLWoRMic1LtjoN9zdODLQ9ThI4iPARJOCttP5cIurgauLexYhmrHA4PEHRRjq9ZfRaRUW6pJbHT5LBnMOCNtz87STSTYgu6rbgMVZrxmKfj",
      "lF5Uz5uM035M3qPP9u6vFh/Y6DytMz/VER9eLsE8c00AXDT322lUMRihW3hPucfrV3LyAcbDPEQXVkFTnpL1wW69G2vRc4R7tGrAp/3FTLu8guj378YJFNtq9YbmJdK0QdwGrTWLyOggo3hNjIGJ8Kgox+Lnu7XmkAFhuuS+3HkkKxX4blG9/hDrBM/ca9oVIrzDYwu72hjrPKt26UpmvmJNuH3hkM3ofg=="

    ];

  </script>
</body>
</html>


